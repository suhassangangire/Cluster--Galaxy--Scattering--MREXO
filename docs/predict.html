<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.6.2" />
<title>mrexo.predict API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase;cursor:pointer}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>mrexo.predict</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>Source code</summary>
<pre><code class="python">import numpy as np
import os
from scipy.stats.mstats import mquantiles
from scipy.interpolate import interp2d
import matplotlib.pyplot as plt
from matplotlib.lines import Line2D
from multiprocessing import Pool,cpu_count

from .mle_utils import cond_density_quantile
from .utils import _load_lookup_table
from .plot import plot_r_given_m_relation, plot_m_given_r_relation

pwd = os.path.dirname(__file__)
np.warnings.filterwarnings(&#39;ignore&#39;)

def predict_from_measurement(measurement, measurement_sigma=None,
            predict = &#39;Mass&#39;, result_dir=None, dataset=&#39;mdwarf&#39;,
            is_posterior=False, qtl=[0.16,0.84], show_plot=False,
            use_lookup=False):
    &#34;&#34;&#34;
    Predict mass from given radius, or radius from mass for a single object.
    Function can be used to predict from a single measurement (w/ or w/o error), or from a posterior distribution.
    \nINPUTS:
        measurement: Numpy array of measurement/s. Always in linear scale.
        measurement_sigma: Numpy array of radius uncertainties. Assumes
            symmetrical uncertainty. Default : None. Always in linear scale.
        predict: The quantity that is being predicted. 
                If = &#39;Mass&#39;, will give mass given input radius.
                Else, can predict radius from mass, if = &#39;Radius&#39;.
        result_dir: The directory where the results of the fit are stored.
                Default is None. If None, then will either use M-dwarf or
                Kepler fits (supplied with package).
        dataset: If result_dir == None, then will use included fits for
                M-dwarfs or Kepler dataset.
                To run the M-dwarf or Kepler fit, define result_dir as None,
                and then dataset=&#39;mdwarf&#39;, or dataset=&#39;kepler&#39;
                The Kepler dataset has been explained in Ning et al. 2018.
                The M-dwarf dataset has been explained in Kanodia et al. 2019.
        is_posterior: If the input radii is a posterior sample, 
                is_posterior=True, else False.
                Default=False
        qtl: 2 element array or list with the quantiles that will be returned.
                Default is 0.16 and 0.84. qtl=[0.16,0.84].
                If is_posterior=True, qtl will not be considered.
        show_plot: Boolean. Default=False. 
                If True, will plot the conditional Mass - Radius relationship,
                and show the predicted point.
        use_lookup: If True, will try to use lookup table.
                If lookup table does not exist, will give warning and 
                calculate the prediction using analytic method. 
                Can only be used for posterior prediction.
    OUTPUTS:
        
        outputs: Tuple with the predicted mass
                (or distribution of masses if input is a posterior),
                and the quantile distribution according to
                the &#39;qtl&#39; input parameter.
        iron_planet: Corresponding predicted quantity for a 100% Iron planet.
                Example: If predicting mass from radius, iron_planet will be
                the mass of a 100% Iron planet for the radius. Similarly for
                radius predictions from mass. This should be used as a reality
                check, in the small planet mass regime,where the uncertainties
                dominate, and can give unphysical results.
    EXAMPLE:
        
        from mrexo import predict_from_measurement
        import os
        import numpy as np
        pwd = &#39;~/mrexo_working/&#39;

        #Below example predicts the mass for a radius of log10(1) Earth radii 
        #exoplanet, with no measurement uncertainty from
        #the fit results in &#39;M_dwarfs_deg_cv&#39;
        
        result_dir = os.path.join(pwd,&#39;M_dwarfs_deg_cv&#39;)
        predicted_mass, qtls = predict_from_measurement(measurement=1, 
                               measurement_sigma=None,
                               result_dir=result_dir, 
                            is_posterior=False, is_log=True)

        #Below example predicts the mass for a radius of log10(1) Earth radii 
        #exoplanet with uncertainty of 0.1 Earth Radii on the included Mdwarf fit.
        predicted_mass, qtls = predict_from_measurement(
                                measurement=1, measurement_sigma=0.1, 
                                result_dir=None, dataset=&#39;mdwarf&#39;,
                                is_posterior=False,
                                is_log=True)

        #Below example predicts the radius for a mass of log10(1) Earth mass 
        #exoplanet with uncertainty of 0.1 Earth Mass on the included Mdwarf fit.
        #Similary for Kepler dataset.
        predicted_mass, qtls = predict_from_measurement(
                                measurement=1, measurement_sigma=0.1,
                                predict = &#39;radius&#39;,
                                result_dir=None, dataset=&#39;mdwarf&#39;, 
                                is_posterior=False, is_log=True)
    &#34;&#34;&#34;

    dataset = dataset.replace(&#39; &#39;, &#39;&#39;).replace(&#39;-&#39;, &#39;&#39;).lower()
    predict = predict.replace(&#39; &#39;, &#39;&#39;).replace(&#39;-&#39;, &#39;&#39;).lower()

    # Define the result directory.
    mdwarf_resultdir = os.path.join(pwd, &#39;datasets&#39;, &#39;M_dwarfs_20181214&#39;)
    kepler_resultdir = os.path.join(pwd, &#39;datasets&#39;, &#39;Kepler_Ning_etal_20170605&#39;)

    if result_dir == None:
        if dataset == &#39;mdwarf&#39;:
            result_dir = mdwarf_resultdir
        elif dataset == &#39;kepler&#39;:
            result_dir = kepler_resultdir

    if measurement_sigma == 0:
        measurement_sigma = None

    input_location = os.path.join(result_dir, &#39;input&#39;)
    output_location = os.path.join(result_dir, &#39;output&#39;)

    # Load the results from the directory
    Mass_min, Mass_max = np.loadtxt(os.path.join(input_location, &#39;Mass_bounds.txt&#39;))
    Radius_min, Radius_max = np.loadtxt(os.path.join(input_location, &#39;Radius_bounds.txt&#39;))
    weights_mle = np.loadtxt(os.path.join(output_location,&#39;weights.txt&#39;))
    R_points = np.loadtxt(os.path.join(output_location, &#39;R_points.txt&#39;))

    degree = int(np.sqrt(len(weights_mle)))
    deg_vec = np.arange(1,degree+1)

    # Convert linear to log10.
    log_measurement = np.log10(measurement)
    if measurement_sigma:
        log_measurement_sigma = 0.434 * measurement_sigma / measurement
    else:
        log_measurement_sigma = None


    if predict == &#39;mass&#39;:
        predict_min, predict_max = Mass_min, Mass_max
        measurement_min, measurement_max = Radius_min, Radius_max
        w_hat = weights_mle
        lookup_fname = &#39;lookup_m_given_r_interp2d.npy&#39;
        Mass_iron = mass_100_percent_iron_planet(np.min(log_measurement))
        iron_planet = Mass_iron

        if np.min(log_measurement) &lt; np.log10(1.3):
            print(&#39;Mass of 100% Iron planet of {} Earth Radii = {} Earth Mass (Fortney, Marley and Barnes 2007)&#39;.format(10**np.min(log_measurement), 10**Mass_iron))
    else:
        predict_min, predict_max = Radius_min, Radius_max
        measurement_min, measurement_max = Mass_min, Mass_max
        w_hat = np.reshape(weights_mle,(degree,degree)).T.flatten()
        lookup_fname = &#39;lookup_r_given_m_interp2d.npy&#39;
        Radius_iron = radius_100_percent_iron_planet(np.min(log_measurement))
        print(&#39;Radius of 100% Iron planet of {} Earth Mass = {} Earth Radii (Fortney, Marley and Barnes 2007)&#39;.format(10**np.min(log_measurement), 10**Radius_iron))

        iron_planet = Radius_iron


    ########################################################

    # Check if single measurement or posterior distribution.
    if is_posterior == False:

            predicted_value = cond_density_quantile(y=log_measurement, y_std=log_measurement_sigma, y_max=measurement_max,
                                                        y_min=measurement_min, x_max=predict_max, x_min=predict_min,
                                                        deg=degree, deg_vec = deg_vec,
                                                        w_hat=w_hat, qtl=np.insert(np.array(qtl),0,0.5))
            predicted_median = predicted_value[2][0]
            predicted_qtl = predicted_value[2][1:]

            outputs = [predicted_median, np.array(predicted_qtl), iron_planet]

            if show_plot == True:

                if np.size(qtl)==2:
                    predicted_lower_quantile, predicted_upper_quantile = predicted_qtl
                else:
                    # If finding multiple quantiles, do not plot errorbar on predicted value in plot
                    predicted_lower_quantile, predicted_upper_quantile = predicted_median, predicted_median
    
                if predict == &#39;mass&#39;:
                    fig, ax, handles = plot_m_given_r_relation(result_dir=result_dir)
                    ax.plot(10**R_points, 10**mass_100_percent_iron_planet(R_points), &#39;k&#39;)
                    handles.append(Line2D([0], [0], color=&#39;k&#39;,  label=r&#39;100$\%$ Iron planet&#39;))
                else:
                    fig, ax, handles = plot_r_given_m_relation(result_dir=result_dir)
    
                yerr = np.array([[10**predicted_median - 10**predicted_lower_quantile, 10**predicted_upper_quantile - 10**predicted_median]]).T
    
                plt.hlines(10**predicted_median, 10**measurement_min, 10**measurement_max, linestyle = &#39;dashed&#39;, colors = &#39;darkgrey&#39;)
                plt.vlines(10**log_measurement, 10**predict_min, 10**predict_max,linestyle = &#39;dashed&#39;, colors = &#39;darkgrey&#39;)
                ax.errorbar(x=measurement, y=10**predicted_median, xerr=measurement_sigma,
                            yerr=yerr,fmt=&#39;o&#39;, color = &#39;green&#39;)
                handles.append(Line2D([0], [0], color=&#39;green&#39;, marker=&#39;o&#39;,  label=&#39;Predicted value&#39;))
                plt.legend(handles=handles)
                plt.show(block=False)

    ###########################################################

    elif is_posterior == True:

        n = np.size(measurement)
        random_quantile = np.zeros(n)
        lookup_flag = None

        if use_lookup == True:
            try:
                lookup = _load_lookup_table(os.path.join(output_location,lookup_fname))
                lookup_flag = 1
                for i in range(0,n):
                    qtl_check = np.random.random()
                    random_quantile[i] = lookup(qtl_check, log_measurement[i])
            except FileNotFoundError:
                print(&#39;Error: Trying to use lookup table when it does not exist. Run script to generate lookup table or set use_lookup = False.&#39;)

        if not lookup_flag:
            for i in range(0,n):
                qtl_check = np.random.random()
                results = cond_density_quantile(y=log_measurement[i], y_std=None, y_max=measurement_max, y_min=measurement_min,
                                                        x_max=predict_max, x_min=predict_min, deg=degree, deg_vec = deg_vec,
                                                        w_hat=w_hat, qtl=[qtl_check])

                random_quantile[i] = results[2][0]

        outputs = [random_quantile, iron_planet]

        if show_plot == True:

            if predict == &#39;mass&#39;:
                fig, ax, handles = plot_m_given_r_relation(result_dir=result_dir)
                ax.plot(10**R_points, 10**mass_100_percent_iron_planet(R_points), &#39;k&#39;)
                handles.append(Line2D([0], [0], color=&#39;k&#39;,  label=r&#39;100$\%$ Iron planet&#39;))

            else:
                fig, ax, handles = plot_r_given_m_relation(result_dir=result_dir)
            
            # Check if need this if-else block    
            if np.size(qtl)==2:
                # predicted_lower_quantile, predicted_upper_quantile = predicted_qtl
                output_qtl =  mquantiles(outputs[:-1], prob=[0.5, qtl[0], qtl[1]],axis=0,alphap=1,betap=1).data
                measurement_qtl = mquantiles(log_measurement, prob=[0.5, qtl[0], qtl[1]],axis=0,alphap=1,betap=1).data
            else:
                # If finding multiple quantiles, do not plot errorbar on predicted value in plot
                output_qtl =  mquantiles(outputs[:-1], prob=[0.5,0.5],axis=0,alphap=1,betap=1).data
                measurement_qtl = mquantiles(log_measurement, prob=[0.5, 0.5],axis=0,alphap=1,betap=1).data

            # plt.hlines(10**output_qtl[0], 10**measurement_min, 10**measurement_max, linestyle = &#39;dashed&#39;, colors = &#39;darkgrey&#39;)
            # plt.vlines(10**measurement_qtl[0], 10**predict_min, 10**predict_max,linestyle = &#39;dashed&#39;, colors = &#39;darkgrey&#39;)

            plt.plot(measurement,10**random_quantile,&#39;g.&#39;,markersize = 8, alpha = 0.3)

            # ax.errorbar(x=10**measurement_qtl[0], y=10**output_qtl[0], xerr=np.abs(10**measurement_qtl[0] - 10**measurement_qtl[1]),
                        # yerr=np.abs(10**output_qtl[0] - 10**output_qtl[1]),fmt=&#39;o&#39;, color = &#39;green&#39;)
            # handles.append(Line2D([0], [0], color=&#39;green&#39;, marker=&#39;o&#39;,  label=&#39;Predicted value&#39;))
            plt.legend(handles=handles)
            plt.show(block=False)


    return [10**x for x in outputs]



def mass_100_percent_iron_planet(logRadius):
    &#34;&#34;&#34;
    This is from 100% iron curve of Fortney, Marley and Barnes 2007; solving for logM (base 10) via quadratic formula.
    \nINPUT:
        logRadius : Radius of the planet in log10 units
    OUTPUT:
        
        logMass: Mass in log10 units for a 100% iron planet of given radius
    &#34;&#34;&#34;

    Mass_iron = (-0.4938 + np.sqrt(0.4938**2-4*0.0975*(0.7932-10**(logRadius))))/(2*0.0975)
    return Mass_iron

def radius_100_percent_iron_planet(logMass):
    &#34;&#34;&#34;
    This is from 100% iron curve from Fortney, Marley and Barnes 2007; solving for logR (base 10) via quadratic formula.
    \nINPUT:
        logMass : Mass of the planet in log10 units
    OUTPUT:
        
        logRadius: Radius in log10 units for a 100% iron planet of given mass
    &#34;&#34;&#34;

    Radius_iron = np.log10((0.0975*(logMass**2)) + (0.4938*logMass) + 0.7932)
    return Radius_iron

def generate_lookup_table(predict = &#39;Mass&#39;, result_dir = None, cores = 1):
    &#34;&#34;&#34;
    Generate lookup table size 1000x1000 to make the prediction function faster.
    In log10 units.
    Then in predict_from_measurement() set use_lookup = True.
    \nINPUTS:
        predict_quantity: To predict mass from radius, set to &#39;mass&#39;. To go the other way,
                          set to &#39;radius&#39;. Default = &#39;Mass&#39;
        result_dir: Directory generated by the fitting procedure.
        cores
    OUTPUT:

        The generated lookup table is saved in /result_dir/output/ in the form
        of a .txt file as well as a .npy file which has the 2D interpolated version
        of the lookup table.
        
    EXAMPLE:
        
        ## To generate lookup table to get mass from radius
        from mrexo.predict import generate_lookup_table
        kepler_result = &#39;/storage/home/s/szk381/work/mrexo/mrexo/datasets/Kepler_Ning_etal_20170605&#39;
        if __name__ == &#39;__main__&#39;:
            generate_lookup_table(result_dir = kepler_result, predict_quantity = &#39;Mass&#39;, cores = 10)
    &#34;&#34;&#34;

    predict_quantity = predict.replace(&#39; &#39;, &#39;&#39;).replace(&#39;-&#39;, &#39;&#39;).lower()

    input_location = os.path.join(result_dir, &#39;input&#39;)
    output_location = os.path.join(result_dir, &#39;output&#39;)
    Mass_min, Mass_max = np.loadtxt(os.path.join(input_location, &#39;Mass_bounds.txt&#39;))
    Radius_min, Radius_max = np.loadtxt(os.path.join(input_location, &#39;Radius_bounds.txt&#39;))

    lookup_grid_size = 1000

    qtl_steps = np.linspace(0,1,lookup_grid_size)

    if predict_quantity == &#39;mass&#39;:
        search_steps = np.linspace(Radius_min, Radius_max, lookup_grid_size)
        fname = &#39;lookup_m_given_r&#39;
        comment = &#39;Lookup table for predicting log(Mass) given log(Radius) and certain quantile.&#39;
    else:
        search_steps = np.linspace(Mass_min, Mass_max, lookup_grid_size)
        fname = &#39;lookup_r_given_m&#39;
        comment = &#39;Lookup table for predicting log(Radius) given log(Mass) and certain quantile.&#39;

    if cores &lt;= 1:
        lookup_table = np.zeros((lookup_grid_size, lookup_grid_size))
        for i in range(0,lookup_grid_size):
            lookup_table[i,:] = np.log10(predict_from_measurement(measurement = 10**search_steps[i], qtl = qtl_steps,
                                result_dir = result_dir, predict = predict_quantity)[1])
            if i%100==0:
                print(i)
    else:
        lookup_inputs = ((10**search_steps[i], qtl_steps, result_dir, predict_quantity) for i in range(lookup_grid_size))
        pool = Pool(processes=cores)
        lookup_table = list(pool.imap(lookup_table_parallelize,lookup_inputs))


    np.savetxt(os.path.join(output_location,fname+&#39;.txt&#39;), lookup_table, comments=&#39;#&#39;, header=comment)

    interp = interp2d(qtl_steps, search_steps, lookup_table)
    print(interp)
    np.save(os.path.join(output_location,fname+&#39;_interp2d.npy&#39;), interp)

def lookup_table_parallelize(inputs):
    return np.log10(predict_from_measurement(measurement = inputs[0], qtl = inputs[1],
                                result_dir = inputs[2], predict = inputs[3])[1])</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="mrexo.predict.generate_lookup_table"><code class="name flex">
<span>def <span class="ident">generate_lookup_table</span></span>(<span>predict='Mass', result_dir=None, cores=1)</span>
</code></dt>
<dd>
<section class="desc"><p>Generate lookup table size 1000x1000 to make the prediction function faster.
In log10 units.
Then in predict_from_measurement() set use_lookup = True.</p>
<h2 id="inputs">INPUTS</h2>
<pre><code>predict_quantity: To predict mass from radius, set to 'mass'. To go the other way,
                  set to 'radius'. Default = 'Mass'
result_dir: Directory generated by the fitting procedure.
cores
</code></pre>
<p>OUTPUT:</p>
<pre><code>The generated lookup table is saved in /result_dir/output/ in the form
of a .txt file as well as a .npy file which has the 2D interpolated version
of the lookup table.
</code></pre>
<p>EXAMPLE:</p>
<pre><code>## To generate lookup table to get mass from radius
from mrexo.predict import generate_lookup_table
kepler_result = '/storage/home/s/szk381/work/mrexo/mrexo/datasets/Kepler_Ning_etal_20170605'
if __name__ == '__main__':
    generate_lookup_table(result_dir = kepler_result, predict_quantity = 'Mass', cores = 10)
</code></pre></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def generate_lookup_table(predict = &#39;Mass&#39;, result_dir = None, cores = 1):
    &#34;&#34;&#34;
    Generate lookup table size 1000x1000 to make the prediction function faster.
    In log10 units.
    Then in predict_from_measurement() set use_lookup = True.
    \nINPUTS:
        predict_quantity: To predict mass from radius, set to &#39;mass&#39;. To go the other way,
                          set to &#39;radius&#39;. Default = &#39;Mass&#39;
        result_dir: Directory generated by the fitting procedure.
        cores
    OUTPUT:

        The generated lookup table is saved in /result_dir/output/ in the form
        of a .txt file as well as a .npy file which has the 2D interpolated version
        of the lookup table.
        
    EXAMPLE:
        
        ## To generate lookup table to get mass from radius
        from mrexo.predict import generate_lookup_table
        kepler_result = &#39;/storage/home/s/szk381/work/mrexo/mrexo/datasets/Kepler_Ning_etal_20170605&#39;
        if __name__ == &#39;__main__&#39;:
            generate_lookup_table(result_dir = kepler_result, predict_quantity = &#39;Mass&#39;, cores = 10)
    &#34;&#34;&#34;

    predict_quantity = predict.replace(&#39; &#39;, &#39;&#39;).replace(&#39;-&#39;, &#39;&#39;).lower()

    input_location = os.path.join(result_dir, &#39;input&#39;)
    output_location = os.path.join(result_dir, &#39;output&#39;)
    Mass_min, Mass_max = np.loadtxt(os.path.join(input_location, &#39;Mass_bounds.txt&#39;))
    Radius_min, Radius_max = np.loadtxt(os.path.join(input_location, &#39;Radius_bounds.txt&#39;))

    lookup_grid_size = 1000

    qtl_steps = np.linspace(0,1,lookup_grid_size)

    if predict_quantity == &#39;mass&#39;:
        search_steps = np.linspace(Radius_min, Radius_max, lookup_grid_size)
        fname = &#39;lookup_m_given_r&#39;
        comment = &#39;Lookup table for predicting log(Mass) given log(Radius) and certain quantile.&#39;
    else:
        search_steps = np.linspace(Mass_min, Mass_max, lookup_grid_size)
        fname = &#39;lookup_r_given_m&#39;
        comment = &#39;Lookup table for predicting log(Radius) given log(Mass) and certain quantile.&#39;

    if cores &lt;= 1:
        lookup_table = np.zeros((lookup_grid_size, lookup_grid_size))
        for i in range(0,lookup_grid_size):
            lookup_table[i,:] = np.log10(predict_from_measurement(measurement = 10**search_steps[i], qtl = qtl_steps,
                                result_dir = result_dir, predict = predict_quantity)[1])
            if i%100==0:
                print(i)
    else:
        lookup_inputs = ((10**search_steps[i], qtl_steps, result_dir, predict_quantity) for i in range(lookup_grid_size))
        pool = Pool(processes=cores)
        lookup_table = list(pool.imap(lookup_table_parallelize,lookup_inputs))


    np.savetxt(os.path.join(output_location,fname+&#39;.txt&#39;), lookup_table, comments=&#39;#&#39;, header=comment)

    interp = interp2d(qtl_steps, search_steps, lookup_table)
    print(interp)
    np.save(os.path.join(output_location,fname+&#39;_interp2d.npy&#39;), interp)</code></pre>
</details>
</dd>
<dt id="mrexo.predict.lookup_table_parallelize"><code class="name flex">
<span>def <span class="ident">lookup_table_parallelize</span></span>(<span>inputs)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def lookup_table_parallelize(inputs):
    return np.log10(predict_from_measurement(measurement = inputs[0], qtl = inputs[1],
                                result_dir = inputs[2], predict = inputs[3])[1])</code></pre>
</details>
</dd>
<dt id="mrexo.predict.mass_100_percent_iron_planet"><code class="name flex">
<span>def <span class="ident">mass_100_percent_iron_planet</span></span>(<span>logRadius)</span>
</code></dt>
<dd>
<section class="desc"><p>This is from 100% iron curve of Fortney, Marley and Barnes 2007; solving for logM (base 10) via quadratic formula.</p>
<h2 id="input">INPUT</h2>
<pre><code>logRadius : Radius of the planet in log10 units
</code></pre>
<p>OUTPUT:</p>
<pre><code>logMass: Mass in log10 units for a 100% iron planet of given radius
</code></pre></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def mass_100_percent_iron_planet(logRadius):
    &#34;&#34;&#34;
    This is from 100% iron curve of Fortney, Marley and Barnes 2007; solving for logM (base 10) via quadratic formula.
    \nINPUT:
        logRadius : Radius of the planet in log10 units
    OUTPUT:
        
        logMass: Mass in log10 units for a 100% iron planet of given radius
    &#34;&#34;&#34;

    Mass_iron = (-0.4938 + np.sqrt(0.4938**2-4*0.0975*(0.7932-10**(logRadius))))/(2*0.0975)
    return Mass_iron</code></pre>
</details>
</dd>
<dt id="mrexo.predict.predict_from_measurement"><code class="name flex">
<span>def <span class="ident">predict_from_measurement</span></span>(<span>measurement, measurement_sigma=None, predict='Mass', result_dir=None, dataset='mdwarf', is_posterior=False, qtl=[0.16, 0.84], show_plot=False, use_lookup=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Predict mass from given radius, or radius from mass for a single object.
Function can be used to predict from a single measurement (w/ or w/o error), or from a posterior distribution.</p>
<h2 id="inputs">INPUTS</h2>
<pre><code>measurement: Numpy array of measurement/s. Always in linear scale.
measurement_sigma: Numpy array of radius uncertainties. Assumes
    symmetrical uncertainty. Default : None. Always in linear scale.
predict: The quantity that is being predicted. 
        If = 'Mass', will give mass given input radius.
        Else, can predict radius from mass, if = 'Radius'.
result_dir: The directory where the results of the fit are stored.
        Default is None. If None, then will either use M-dwarf or
        Kepler fits (supplied with package).
dataset: If result_dir == None, then will use included fits for
        M-dwarfs or Kepler dataset.
        To run the M-dwarf or Kepler fit, define result_dir as None,
        and then dataset='mdwarf', or dataset='kepler'
        The Kepler dataset has been explained in Ning et al. 2018.
        The M-dwarf dataset has been explained in Kanodia et al. 2019.
is_posterior: If the input radii is a posterior sample, 
        is_posterior=True, else False.
        Default=False
qtl: 2 element array or list with the quantiles that will be returned.
        Default is 0.16 and 0.84. qtl=[0.16,0.84].
        If is_posterior=True, qtl will not be considered.
show_plot: Boolean. Default=False. 
        If True, will plot the conditional Mass - Radius relationship,
        and show the predicted point.
use_lookup: If True, will try to use lookup table.
        If lookup table does not exist, will give warning and 
        calculate the prediction using analytic method. 
        Can only be used for posterior prediction.
</code></pre>
<p>OUTPUTS:</p>
<pre><code>outputs: Tuple with the predicted mass
        (or distribution of masses if input is a posterior),
        and the quantile distribution according to
        the 'qtl' input parameter.
iron_planet: Corresponding predicted quantity for a 100% Iron planet.
        Example: If predicting mass from radius, iron_planet will be
        the mass of a 100% Iron planet for the radius. Similarly for
        radius predictions from mass. This should be used as a reality
        check, in the small planet mass regime,where the uncertainties
        dominate, and can give unphysical results.
</code></pre>
<p>EXAMPLE:</p>
<pre><code>from mrexo import predict_from_measurement
import os
import numpy as np
pwd = '~/mrexo_working/'

#Below example predicts the mass for a radius of log10(1) Earth radii 
#exoplanet, with no measurement uncertainty from
#the fit results in 'M_dwarfs_deg_cv'

result_dir = os.path.join(pwd,'M_dwarfs_deg_cv')
predicted_mass, qtls = predict_from_measurement(measurement=1, 
                       measurement_sigma=None,
                       result_dir=result_dir, 
                    is_posterior=False, is_log=True)

#Below example predicts the mass for a radius of log10(1) Earth radii 
#exoplanet with uncertainty of 0.1 Earth Radii on the included Mdwarf fit.
predicted_mass, qtls = predict_from_measurement(
                        measurement=1, measurement_sigma=0.1, 
                        result_dir=None, dataset='mdwarf',
                        is_posterior=False,
                        is_log=True)

#Below example predicts the radius for a mass of log10(1) Earth mass 
#exoplanet with uncertainty of 0.1 Earth Mass on the included Mdwarf fit.
#Similary for Kepler dataset.
predicted_mass, qtls = predict_from_measurement(
                        measurement=1, measurement_sigma=0.1,
                        predict = 'radius',
                        result_dir=None, dataset='mdwarf', 
                        is_posterior=False, is_log=True)
</code></pre></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def predict_from_measurement(measurement, measurement_sigma=None,
            predict = &#39;Mass&#39;, result_dir=None, dataset=&#39;mdwarf&#39;,
            is_posterior=False, qtl=[0.16,0.84], show_plot=False,
            use_lookup=False):
    &#34;&#34;&#34;
    Predict mass from given radius, or radius from mass for a single object.
    Function can be used to predict from a single measurement (w/ or w/o error), or from a posterior distribution.
    \nINPUTS:
        measurement: Numpy array of measurement/s. Always in linear scale.
        measurement_sigma: Numpy array of radius uncertainties. Assumes
            symmetrical uncertainty. Default : None. Always in linear scale.
        predict: The quantity that is being predicted. 
                If = &#39;Mass&#39;, will give mass given input radius.
                Else, can predict radius from mass, if = &#39;Radius&#39;.
        result_dir: The directory where the results of the fit are stored.
                Default is None. If None, then will either use M-dwarf or
                Kepler fits (supplied with package).
        dataset: If result_dir == None, then will use included fits for
                M-dwarfs or Kepler dataset.
                To run the M-dwarf or Kepler fit, define result_dir as None,
                and then dataset=&#39;mdwarf&#39;, or dataset=&#39;kepler&#39;
                The Kepler dataset has been explained in Ning et al. 2018.
                The M-dwarf dataset has been explained in Kanodia et al. 2019.
        is_posterior: If the input radii is a posterior sample, 
                is_posterior=True, else False.
                Default=False
        qtl: 2 element array or list with the quantiles that will be returned.
                Default is 0.16 and 0.84. qtl=[0.16,0.84].
                If is_posterior=True, qtl will not be considered.
        show_plot: Boolean. Default=False. 
                If True, will plot the conditional Mass - Radius relationship,
                and show the predicted point.
        use_lookup: If True, will try to use lookup table.
                If lookup table does not exist, will give warning and 
                calculate the prediction using analytic method. 
                Can only be used for posterior prediction.
    OUTPUTS:
        
        outputs: Tuple with the predicted mass
                (or distribution of masses if input is a posterior),
                and the quantile distribution according to
                the &#39;qtl&#39; input parameter.
        iron_planet: Corresponding predicted quantity for a 100% Iron planet.
                Example: If predicting mass from radius, iron_planet will be
                the mass of a 100% Iron planet for the radius. Similarly for
                radius predictions from mass. This should be used as a reality
                check, in the small planet mass regime,where the uncertainties
                dominate, and can give unphysical results.
    EXAMPLE:
        
        from mrexo import predict_from_measurement
        import os
        import numpy as np
        pwd = &#39;~/mrexo_working/&#39;

        #Below example predicts the mass for a radius of log10(1) Earth radii 
        #exoplanet, with no measurement uncertainty from
        #the fit results in &#39;M_dwarfs_deg_cv&#39;
        
        result_dir = os.path.join(pwd,&#39;M_dwarfs_deg_cv&#39;)
        predicted_mass, qtls = predict_from_measurement(measurement=1, 
                               measurement_sigma=None,
                               result_dir=result_dir, 
                            is_posterior=False, is_log=True)

        #Below example predicts the mass for a radius of log10(1) Earth radii 
        #exoplanet with uncertainty of 0.1 Earth Radii on the included Mdwarf fit.
        predicted_mass, qtls = predict_from_measurement(
                                measurement=1, measurement_sigma=0.1, 
                                result_dir=None, dataset=&#39;mdwarf&#39;,
                                is_posterior=False,
                                is_log=True)

        #Below example predicts the radius for a mass of log10(1) Earth mass 
        #exoplanet with uncertainty of 0.1 Earth Mass on the included Mdwarf fit.
        #Similary for Kepler dataset.
        predicted_mass, qtls = predict_from_measurement(
                                measurement=1, measurement_sigma=0.1,
                                predict = &#39;radius&#39;,
                                result_dir=None, dataset=&#39;mdwarf&#39;, 
                                is_posterior=False, is_log=True)
    &#34;&#34;&#34;

    dataset = dataset.replace(&#39; &#39;, &#39;&#39;).replace(&#39;-&#39;, &#39;&#39;).lower()
    predict = predict.replace(&#39; &#39;, &#39;&#39;).replace(&#39;-&#39;, &#39;&#39;).lower()

    # Define the result directory.
    mdwarf_resultdir = os.path.join(pwd, &#39;datasets&#39;, &#39;M_dwarfs_20181214&#39;)
    kepler_resultdir = os.path.join(pwd, &#39;datasets&#39;, &#39;Kepler_Ning_etal_20170605&#39;)

    if result_dir == None:
        if dataset == &#39;mdwarf&#39;:
            result_dir = mdwarf_resultdir
        elif dataset == &#39;kepler&#39;:
            result_dir = kepler_resultdir

    if measurement_sigma == 0:
        measurement_sigma = None

    input_location = os.path.join(result_dir, &#39;input&#39;)
    output_location = os.path.join(result_dir, &#39;output&#39;)

    # Load the results from the directory
    Mass_min, Mass_max = np.loadtxt(os.path.join(input_location, &#39;Mass_bounds.txt&#39;))
    Radius_min, Radius_max = np.loadtxt(os.path.join(input_location, &#39;Radius_bounds.txt&#39;))
    weights_mle = np.loadtxt(os.path.join(output_location,&#39;weights.txt&#39;))
    R_points = np.loadtxt(os.path.join(output_location, &#39;R_points.txt&#39;))

    degree = int(np.sqrt(len(weights_mle)))
    deg_vec = np.arange(1,degree+1)

    # Convert linear to log10.
    log_measurement = np.log10(measurement)
    if measurement_sigma:
        log_measurement_sigma = 0.434 * measurement_sigma / measurement
    else:
        log_measurement_sigma = None


    if predict == &#39;mass&#39;:
        predict_min, predict_max = Mass_min, Mass_max
        measurement_min, measurement_max = Radius_min, Radius_max
        w_hat = weights_mle
        lookup_fname = &#39;lookup_m_given_r_interp2d.npy&#39;
        Mass_iron = mass_100_percent_iron_planet(np.min(log_measurement))
        iron_planet = Mass_iron

        if np.min(log_measurement) &lt; np.log10(1.3):
            print(&#39;Mass of 100% Iron planet of {} Earth Radii = {} Earth Mass (Fortney, Marley and Barnes 2007)&#39;.format(10**np.min(log_measurement), 10**Mass_iron))
    else:
        predict_min, predict_max = Radius_min, Radius_max
        measurement_min, measurement_max = Mass_min, Mass_max
        w_hat = np.reshape(weights_mle,(degree,degree)).T.flatten()
        lookup_fname = &#39;lookup_r_given_m_interp2d.npy&#39;
        Radius_iron = radius_100_percent_iron_planet(np.min(log_measurement))
        print(&#39;Radius of 100% Iron planet of {} Earth Mass = {} Earth Radii (Fortney, Marley and Barnes 2007)&#39;.format(10**np.min(log_measurement), 10**Radius_iron))

        iron_planet = Radius_iron


    ########################################################

    # Check if single measurement or posterior distribution.
    if is_posterior == False:

            predicted_value = cond_density_quantile(y=log_measurement, y_std=log_measurement_sigma, y_max=measurement_max,
                                                        y_min=measurement_min, x_max=predict_max, x_min=predict_min,
                                                        deg=degree, deg_vec = deg_vec,
                                                        w_hat=w_hat, qtl=np.insert(np.array(qtl),0,0.5))
            predicted_median = predicted_value[2][0]
            predicted_qtl = predicted_value[2][1:]

            outputs = [predicted_median, np.array(predicted_qtl), iron_planet]

            if show_plot == True:

                if np.size(qtl)==2:
                    predicted_lower_quantile, predicted_upper_quantile = predicted_qtl
                else:
                    # If finding multiple quantiles, do not plot errorbar on predicted value in plot
                    predicted_lower_quantile, predicted_upper_quantile = predicted_median, predicted_median
    
                if predict == &#39;mass&#39;:
                    fig, ax, handles = plot_m_given_r_relation(result_dir=result_dir)
                    ax.plot(10**R_points, 10**mass_100_percent_iron_planet(R_points), &#39;k&#39;)
                    handles.append(Line2D([0], [0], color=&#39;k&#39;,  label=r&#39;100$\%$ Iron planet&#39;))
                else:
                    fig, ax, handles = plot_r_given_m_relation(result_dir=result_dir)
    
                yerr = np.array([[10**predicted_median - 10**predicted_lower_quantile, 10**predicted_upper_quantile - 10**predicted_median]]).T
    
                plt.hlines(10**predicted_median, 10**measurement_min, 10**measurement_max, linestyle = &#39;dashed&#39;, colors = &#39;darkgrey&#39;)
                plt.vlines(10**log_measurement, 10**predict_min, 10**predict_max,linestyle = &#39;dashed&#39;, colors = &#39;darkgrey&#39;)
                ax.errorbar(x=measurement, y=10**predicted_median, xerr=measurement_sigma,
                            yerr=yerr,fmt=&#39;o&#39;, color = &#39;green&#39;)
                handles.append(Line2D([0], [0], color=&#39;green&#39;, marker=&#39;o&#39;,  label=&#39;Predicted value&#39;))
                plt.legend(handles=handles)
                plt.show(block=False)

    ###########################################################

    elif is_posterior == True:

        n = np.size(measurement)
        random_quantile = np.zeros(n)
        lookup_flag = None

        if use_lookup == True:
            try:
                lookup = _load_lookup_table(os.path.join(output_location,lookup_fname))
                lookup_flag = 1
                for i in range(0,n):
                    qtl_check = np.random.random()
                    random_quantile[i] = lookup(qtl_check, log_measurement[i])
            except FileNotFoundError:
                print(&#39;Error: Trying to use lookup table when it does not exist. Run script to generate lookup table or set use_lookup = False.&#39;)

        if not lookup_flag:
            for i in range(0,n):
                qtl_check = np.random.random()
                results = cond_density_quantile(y=log_measurement[i], y_std=None, y_max=measurement_max, y_min=measurement_min,
                                                        x_max=predict_max, x_min=predict_min, deg=degree, deg_vec = deg_vec,
                                                        w_hat=w_hat, qtl=[qtl_check])

                random_quantile[i] = results[2][0]

        outputs = [random_quantile, iron_planet]

        if show_plot == True:

            if predict == &#39;mass&#39;:
                fig, ax, handles = plot_m_given_r_relation(result_dir=result_dir)
                ax.plot(10**R_points, 10**mass_100_percent_iron_planet(R_points), &#39;k&#39;)
                handles.append(Line2D([0], [0], color=&#39;k&#39;,  label=r&#39;100$\%$ Iron planet&#39;))

            else:
                fig, ax, handles = plot_r_given_m_relation(result_dir=result_dir)
            
            # Check if need this if-else block    
            if np.size(qtl)==2:
                # predicted_lower_quantile, predicted_upper_quantile = predicted_qtl
                output_qtl =  mquantiles(outputs[:-1], prob=[0.5, qtl[0], qtl[1]],axis=0,alphap=1,betap=1).data
                measurement_qtl = mquantiles(log_measurement, prob=[0.5, qtl[0], qtl[1]],axis=0,alphap=1,betap=1).data
            else:
                # If finding multiple quantiles, do not plot errorbar on predicted value in plot
                output_qtl =  mquantiles(outputs[:-1], prob=[0.5,0.5],axis=0,alphap=1,betap=1).data
                measurement_qtl = mquantiles(log_measurement, prob=[0.5, 0.5],axis=0,alphap=1,betap=1).data

            # plt.hlines(10**output_qtl[0], 10**measurement_min, 10**measurement_max, linestyle = &#39;dashed&#39;, colors = &#39;darkgrey&#39;)
            # plt.vlines(10**measurement_qtl[0], 10**predict_min, 10**predict_max,linestyle = &#39;dashed&#39;, colors = &#39;darkgrey&#39;)

            plt.plot(measurement,10**random_quantile,&#39;g.&#39;,markersize = 8, alpha = 0.3)

            # ax.errorbar(x=10**measurement_qtl[0], y=10**output_qtl[0], xerr=np.abs(10**measurement_qtl[0] - 10**measurement_qtl[1]),
                        # yerr=np.abs(10**output_qtl[0] - 10**output_qtl[1]),fmt=&#39;o&#39;, color = &#39;green&#39;)
            # handles.append(Line2D([0], [0], color=&#39;green&#39;, marker=&#39;o&#39;,  label=&#39;Predicted value&#39;))
            plt.legend(handles=handles)
            plt.show(block=False)


    return [10**x for x in outputs]</code></pre>
</details>
</dd>
<dt id="mrexo.predict.radius_100_percent_iron_planet"><code class="name flex">
<span>def <span class="ident">radius_100_percent_iron_planet</span></span>(<span>logMass)</span>
</code></dt>
<dd>
<section class="desc"><p>This is from 100% iron curve from Fortney, Marley and Barnes 2007; solving for logR (base 10) via quadratic formula.</p>
<h2 id="input">INPUT</h2>
<pre><code>logMass : Mass of the planet in log10 units
</code></pre>
<p>OUTPUT:</p>
<pre><code>logRadius: Radius in log10 units for a 100% iron planet of given mass
</code></pre></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def radius_100_percent_iron_planet(logMass):
    &#34;&#34;&#34;
    This is from 100% iron curve from Fortney, Marley and Barnes 2007; solving for logR (base 10) via quadratic formula.
    \nINPUT:
        logMass : Mass of the planet in log10 units
    OUTPUT:
        
        logRadius: Radius in log10 units for a 100% iron planet of given mass
    &#34;&#34;&#34;

    Radius_iron = np.log10((0.0975*(logMass**2)) + (0.4938*logMass) + 0.7932)
    return Radius_iron</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="mrexo" href="index.html">mrexo</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="mrexo.predict.generate_lookup_table" href="#mrexo.predict.generate_lookup_table">generate_lookup_table</a></code></li>
<li><code><a title="mrexo.predict.lookup_table_parallelize" href="#mrexo.predict.lookup_table_parallelize">lookup_table_parallelize</a></code></li>
<li><code><a title="mrexo.predict.mass_100_percent_iron_planet" href="#mrexo.predict.mass_100_percent_iron_planet">mass_100_percent_iron_planet</a></code></li>
<li><code><a title="mrexo.predict.predict_from_measurement" href="#mrexo.predict.predict_from_measurement">predict_from_measurement</a></code></li>
<li><code><a title="mrexo.predict.radius_100_percent_iron_planet" href="#mrexo.predict.radius_100_percent_iron_planet">radius_100_percent_iron_planet</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.6.2</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>