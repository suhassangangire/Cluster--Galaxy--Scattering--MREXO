<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.6.2" />
<title>mrexo.mle_utils API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase;cursor:pointer}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>mrexo.mle_utils</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>Source code</summary>
<pre><code class="python">import numpy as np
from scipy.stats import beta,norm
import scipy
from scipy.integrate import quad
from scipy.optimize import brentq as root
from scipy.optimize import fmin_slsqp, minimize
import datetime,os
from multiprocessing import current_process


from .utils import _logging


########################################
##### Main function: MLE_fit() #########
########################################

def MLE_fit(Mass, Mass_sigma, Radius, Radius_sigma, Mass_bounds, Radius_bounds,
            deg, Log=True, abs_tol=1e-8, output_weights_only=False,
            save_path=None, calc_joint_dist = False, verbose=2):
    &#39;&#39;&#39;
    Perform maximum likelihood estimation to find the weights for the beta density basis functions.
    Also, use those weights to calculate the conditional density distributions.
    Ning et al. 2018 Sec 2.2, Eq 9.

    INPUT:
        Mass: Numpy array of mass measurements. In LINEAR SCALE.
        Mass_sigma: Numpy array of mass uncertainties.
            Assumes symmetrical uncertainty. In LINEAR SCALE.
        Radius: Numpy array of radius measurements. In LINEAR SCALE.
        Radius_sigma: Numpy array of radius uncertainties.
            Assumes symmetrical uncertainty. In LINEAR SCALE.
        Mass_bounds: Bounds for the mass. Log10
        Radius_bounds: Bounds for the radius. Log10
        deg: Degree used for beta densities polynomials. Integer value.
        Log: If True, data is transformed into Log scale. Default=True, 
            since the fitting function always converts data to log scale.
        abs_tol: Absolute tolerance to be used for the numerical integration
            for product of normal and beta distribution. Default : 1e-8
        output_weights_only: If True, only output the estimated weights, 
            else will also output dictionary with keys shown below.
        save_path: Location of folder for auxiliary output files.
        calc_joint_dist: If True, will calculate and output the
            joint distribution of mass and radius.
        verbose: Integer specifying verbosity for logging.
                If 0: Will not log in the log file or print statements.
                If 1: Will write log file only.
                If 2: Will write log file and print statements.

    \nOUTPUT:

        If output_weights_only == True,
        w_hat : Weights for the beta densities.

        If output_weights_only == False,
        output: Output dictionary from fitting using 
                Maximum Likelihood Estimation.
                The keys in the dictionary are:
                &#39;weights&#39; : Weights for beta densities.
                &#39;aic&#39; : Akaike Information Criterion.
                &#39;bic&#39; : Bayesian Information Criterion.
                &#39;M_points&#39; : Sequence of mass points for 
                    initial fitting w/o bootstrap.
                &#39;R_points&#39; : Sequence of radius points for
                    initial fitting w/o bootstrap.
                &#39;M_cond_R&#39; : Conditional distribution of mass given radius.
                &#39;M_cond_R_var&#39; : Variance for the Conditional distribution 
                    of mass given radius.
                &#39;M_cond_R_quantile&#39; : Quantiles for the Conditional distribution 
                    of mass given radius.
                &#39;R_cond_M&#39; : Conditional distribution of radius given mass.
                &#39;R_cond_M_var&#39; : Variance for the Conditional distribution
                    of radius given mass.
                &#39;R_cond_M_quantile&#39; : Quantiles for the Conditional distribution 
                    of radius given mass.


                if calc_joint_dist == True:
                &#39;joint_dist&#39; : Joint distribution of mass AND radius.
    EXAMPLE:

            result = MLE_fit(Mass=Mass, Radius=Radius, Mass_sigma=Mass_sigma, 
                            Radius_sigma=Radius_sigma,
                            Mass_bounds=Mass_bounds, Radius_bounds=Radius_bounds, 
                            deg=int(deg_choose), abs_tol=abs_tol,
                            save_path=aux_output_location)
    &#39;&#39;&#39;
    print(&#39;New MLE&#39;)
    starttime = datetime.datetime.now()
    if save_path is None:
        save_path = os.path.dirname(__file__)


    message = &#39;\n====\nStarted run at {}\n&#39;.format(starttime)
    _ = _logging(message=message, filepath=save_path, verbose=verbose, append=True)


    n = np.shape(Mass)[0]
    Mass_max = Mass_bounds[1]
    Mass_min = Mass_bounds[0]
    Radius_max = Radius_bounds[1]
    Radius_min = Radius_bounds[0]

    ########################################################################
    # Integration to find C matrix (input for log likelihood maximization.)
    ########################################################################
    C_pdf = calc_C_matrix(n=n, deg=deg, M=Mass, Mass_sigma=Mass_sigma, Mass_max=Mass_max, Mass_min=Mass_min,
                        R=Radius, Radius_sigma=Radius_sigma, Radius_max=Radius_max, Radius_min=Radius_min,
                        Log=Log, abs_tol=abs_tol, save_path=save_path, verbose=verbose)

    message = &#39;Finished Integration at {}. Calculated the PDF for Mass and Radius for Integrated beta and normal density &#39;.format(datetime.datetime.now())
    _ = _logging(message=message, filepath=save_path, verbose=verbose, append=True)


    ###########################################################
    # Run optimization to find the weights
    ###########################################################

    # Ensure that the weights always sum up to 1.
    def eqn(w):
        return np.sum(w) - 1

    # Function input to optimizer
    def fn1(w):
        a = - np.sum(np.log(np.matmul(w,C_pdf)))
        return a

    # Define a list of lists of bounds
    bounds = [[0,1]]*(deg-2)**2
    # Initial value for weights
    x0 = np.repeat(1./(deg**2),(deg-2)**2)

    # Run optimization to find optimum value for each degree (weights). These are the coefficients for the beta densities being used as a linear basis.
    opt_result = fmin_slsqp(fn1, x0, bounds=bounds, f_eqcons=eqn, iter=250, full_output=True, iprint=1,
                            epsilon=1e-5, acc=1e-5)
    message = &#39;Optimization run finished at {}, with {} iterations. Exit Code = {}&#39;.format(datetime.datetime.now(),
            opt_result[2], opt_result[3], opt_result[4])
    _ = _logging(message=message, filepath=save_path, verbose=verbose, append=True)


    unpadded_weight = opt_result[0]
    n_log_lik = opt_result[1]

    # Pad the weight array with zeros for the
    w_sq = np.reshape(unpadded_weight,[deg-2,deg-2])
    w_sq_padded = np.zeros((deg,deg))
    w_sq_padded[1:-1,1:-1] = w_sq
    w_hat = w_sq_padded.flatten()

    if output_weights_only == True:
        return unpadded_weight

    else:
        # Calculate AIC and BIC
        aic = n_log_lik*2 + 2*(deg**2 - 1)
        bic = n_log_lik*2 + np.log(n)*(deg**2 - 1)

        M_seq = np.linspace(Mass_min,Mass_max,100)
        R_seq = np.linspace(Radius_min,Radius_max,100)

        output = {&#39;weights&#39;: w_hat,
                  &#39;aic&#39;: aic,
                  &#39;bic&#39;: bic,
                  &#39;M_points&#39;: M_seq,
                  &#39;R_points&#39;: R_seq}


        deg_vec = np.arange(1,deg+1)

        M_cond_R_median, M_cond_R_var, M_cond_R_quantile = [], [], []
        R_cond_M_median, R_cond_M_var, R_cond_M_quantile = [], [], []

        for i in range(0,len(R_seq)):
            # Conditional Densities with 16% and 84% quantile
            M_cond_R = cond_density_quantile(y = R_seq[i], y_max = Radius_max, y_min = Radius_min,
                            x_max = Mass_max, x_min = Mass_min, deg = deg, deg_vec = deg_vec, w_hat = w_hat, qtl = [0.5,0.16,0.84])[0:3]
            M_cond_R_median.append(M_cond_R[2][0])
            M_cond_R_var.append(M_cond_R[1])
            M_cond_R_quantile.append(M_cond_R[2][1:])

            R_cond_M = cond_density_quantile(y = M_seq[i], y_max=Mass_max, y_min=Mass_min,
                                x_max=Radius_max, x_min=Radius_min, deg=deg, deg_vec = deg_vec,
                                w_hat=np.reshape(w_hat,(deg,deg)).T.flatten(), qtl = [0.5,0.16,0.84])[0:3]
            R_cond_M_median.append(R_cond_M[2][0])
            R_cond_M_var.append(R_cond_M[1])
            R_cond_M_quantile.append(R_cond_M[2][1:])



        # Output everything as dictionary

        output[&#39;M_cond_R&#39;] = M_cond_R_median
        output[&#39;M_cond_R_var&#39;] = M_cond_R_var
        output[&#39;M_cond_R_quantile&#39;] = np.array(M_cond_R_quantile)
        output[&#39;R_cond_M&#39;] = R_cond_M_median
        output[&#39;R_cond_M_var&#39;] = R_cond_M_var
        output[&#39;R_cond_M_quantile&#39;] = np.array(R_cond_M_quantile)

        if calc_joint_dist == True:
            joint_dist = calculate_joint_distribution(R_seq, Radius_min, Radius_max, M_seq, Mass_min, Mass_max, w_hat, abs_tol)
            output[&#39;joint_dist&#39;] = joint_dist

        return output


def calc_C_matrix(n, deg, M, Mass_sigma, Mass_max, Mass_min, R, Radius_sigma, Radius_max, Radius_min, abs_tol, save_path, Log, verbose):
    &#39;&#39;&#39;
    Integrate the product of the normal and beta distributions for mass and radius and then take the Kronecker product.

    Refer to Ning et al. 2018 Sec 2.2 Eq 8 and 9.

    \nINPUTS:
        n: Number of data points
        deg: Degree used for beta densities
        Mass: Numpy array of mass measurements. In LINEAR SCALE.
        Mass_sigma: Numpy array of mass uncertainties. Assumes symmetrical uncertainty. In LINEAR SCALE.
        Mass_max, Mass_min : Maximum and minimum value for mass. Log10
        Radius: Numpy array of radius measurements. In LINEAR SCALE.
        Radius_sigma: Numpy array of radius uncertainties. Assumes symmetrical uncertainty. In LINEAR SCALE.
        Radius_max, Radius_min : Maximum and minimum value for radius. Log10
        abs_tol: Absolute tolerance to be used for the numerical integration for product of normal and beta distribution.
                Default : 1e-8
        save_path: Location of folder within results for auxiliary output files
        Log: If True, data is transformed into Log scale. Default=True, since
            fitting function always converts data to log scale.
        verbose: Integer specifying verbosity for logging.
            If 0: Will not log in the log file or print statements.
            If 1: Will write log file only.
            If 2: Will write log file and print statements.

    OUTPUTS:

        C_pdf : Matrix explained in Ning et al. Equation 8. Product of (integrals of (product of normal and beta
                distributions)) for mass and radius.
    &#39;&#39;&#39;
    deg_vec = np.arange(2,deg)

    M_indv_pdf = np.zeros((n, deg-2))
    R_indv_pdf = np.zeros((n, deg-2))
    C_pdf = np.zeros((n, (deg-2)**2))


    message = &#39;Started Integration at {}\n&#39;.format(datetime.datetime.now())
    _ = _logging(message=message, filepath=save_path, verbose=verbose, append=True)



    # Loop across each data point.
    for i in range(0,n):
        M_indv_pdf[i,:] = _find_indv_pdf(M[i], deg, deg_vec, Mass_max, Mass_min, Mass_sigma[i], abs_tol=abs_tol, Log=Log)
        R_indv_pdf[i,:] = _find_indv_pdf(R[i], deg, deg_vec, Radius_max, Radius_min, Radius_sigma[i], abs_tol=abs_tol, Log=Log)
        # print(M[i],Mass_sigma[i], R[i], Radius_sigma[i], Mass_max, Mass_min, Radius_max, Radius_min, np.sum(R_indv_pdf[i,:]))

        # Put M.indv.pdf and R.indv.pdf into a big matrix
        C_pdf[i,:] = np.kron(M_indv_pdf[i], R_indv_pdf[i])

    C_pdf = C_pdf.T

    # Log of 0 throws weird errors
    C_pdf[C_pdf == 0] = 1e-300
    C_pdf[np.where(np.isnan(C_pdf))] = 1e-300
    return C_pdf


def _norm_pdf(x, loc, scale):
    &#39;&#39;&#39;
    Find the PDF for a normal distribution. Identical to scipy.stats.norm.pdf.
    Runs much quicker without the generic function handling.
    &#39;&#39;&#39;
    y = (x - loc)/scale
    return np.exp(-y*y/2)/(np.sqrt(2*np.pi))/scale

def _int_gamma(a):
    return scipy.math.factorial(a-1)


def _beta_pdf(x,a,b):
    f = (_int_gamma(a+b) * x**(a-1)*(1-x)**(b-1))/(_int_gamma(a)*_int_gamma(b))
    return f


def _pdfnorm_beta(x, x_obs, x_std, x_max, x_min, shape1, shape2, Log=True):
    &#39;&#39;&#39;
    Product of normal and beta distribution

    Refer to Ning et al. 2018 Sec 2.2, Eq 8.
    &#39;&#39;&#39;

    if Log == True:
        norm_beta = _norm_pdf(x_obs, loc=10**x, scale=x_std) * _beta_pdf((x - x_min)/(x_max - x_min), a=shape1, b=shape2)/(x_max - x_min)
    else:
        norm_beta = _norm_pdf(x_obs, loc=x, scale=x_std) * _beta_pdf((x - x_min)/(x_max - x_min), a=shape1, b=shape2)/(x_max - x_min)
    return norm_beta

def integrate_function(data, data_std, deg, degree, x_max, x_min, Log=False, abs_tol=1e-8):
    &#39;&#39;&#39;
    Integrate the product of the normal and beta distribution.

    Refer to Ning et al. 2018 Sec 2.2, Eq 8.
    &#39;&#39;&#39;
    x_obs = data
    x_std = data_std
    shape1 = degree
    shape2 = deg - degree + 1
    Log = Log

    integration_product = quad(_pdfnorm_beta, a=x_min, b=x_max,
                          args=(x_obs, x_std, x_max, x_min, shape1, shape2, Log), epsabs = abs_tol, epsrel = 1e-8)
    return integration_product[0]


def _find_indv_pdf(x,deg,deg_vec,x_max,x_min,x_std=None, abs_tol=1e-8, Log=True):
    &#39;&#39;&#39;
    Find the individual probability density Function for a variable.
    When the data has uncertainty, the joint distribution is modelled using a
    convolution of beta and normal distributions.

    Refer to Ning et al. 2018 Sec 2.2, Eq 7 &amp; 8.
    &#39;&#39;&#39;

    if x_std == None:
        x_std = (x - x_min)/(x_max - x_min)
        x_beta_indv = np.array([_beta_pdf(x_std, a=d, b=deg - d + 1)/(x_max - x_min) for d in deg_vec])
    else:
        x_beta_indv = np.array([integrate_function(data=x, data_std=x_std, deg=deg, degree=d, x_max=x_max, x_min=x_min, abs_tol=abs_tol, Log=Log) for d in deg_vec])
    return x_beta_indv


def _marginal_density(x, x_max, x_min, deg, w_hat):
    &#39;&#39;&#39;
    Calculate the marginal density

    Refer to Ning et al. 2018 Sec 2.2, Eq 10
    &#39;&#39;&#39;
    if type(x) == list:
        x = np.array(x)

    deg_vec = np.arange(1,deg+1)
    x_beta_indv = _find_indv_pdf(x,deg, deg_vec, x_max, x_min)
    x__beta_pdf = np.kron(x_beta_indv, np.repeat(1,deg))

    marg_x = np.sum(w_hat * x__beta_pdf)

    return marg_x

def cond_density_quantile(y, y_max, y_min, x_max, x_min, deg, deg_vec, w_hat, y_std=None, qtl=[0.16,0.84], abs_tol=1e-8):
    &#39;&#39;&#39;
    Calculate 16% and 84% quantiles of a conditional density, along with the mean and variance.

    Refer to Ning et al. 2018 Sec 2.2, Eq 10
    &#39;&#39;&#39;
    if type(y) == list:
        y = np.array(y)

    y_beta_indv = _find_indv_pdf(x=y, deg=deg, deg_vec=deg_vec, x_max=y_max, x_min=y_min, x_std=y_std, abs_tol=abs_tol, Log=False)
    y__beta_pdf = np.kron(np.repeat(1,np.max(deg_vec)),y_beta_indv)

    # Equation 10b Ning et al 2018
    denominator = np.sum(w_hat * y__beta_pdf)

    if denominator == 0:
        denominator = np.nan

    # Mean
    mean_beta_indv = (deg_vec * (x_max - x_min) / (deg + 1)) + x_min
    mean_beta = np.kron(mean_beta_indv,y_beta_indv)
    mean_numerator = np.sum(w_hat * mean_beta)
    mean = mean_numerator / denominator

    # Variance
    var_beta_indv = (deg_vec * (deg - deg_vec + 1) * (x_max - x_min)**2 / ((deg + 2)*(deg + 1)**2))
    var_beta = np.kron(var_beta_indv,y_beta_indv)
    var_numerator = np.sum(w_hat * var_beta)
    var = var_numerator / denominator

    # Quantile

    def pbeta_conditional_density(j):
        if type(j) == np.ndarray:
            j = j[0]
        x_indv_cdf = np.array([beta.cdf((j - x_min)/(x_max - x_min), a=d, b=deg - d + 1) for d in deg_vec])
        quantile_numerator = np.sum(w_hat * np.kron(x_indv_cdf,y_beta_indv))
        p_beta = quantile_numerator / denominator

        return p_beta


    def conditional_quantile(q):
        def g(x):
            return pbeta_conditional_density(x) - q
        return root(g,a=x_min, b=x_max, xtol=1e-8, rtol=1e-12)


    if np.size(qtl) == 1:
        qtl = [qtl]
    quantile = [conditional_quantile(i) for i in qtl]

    return mean, var, quantile, denominator, y_beta_indv


def calculate_joint_distribution(R_points, Radius_min, Radius_max, M_points, Mass_min, Mass_max, weights, abs_tol):
    &#39;&#39;&#39;
    Calculcate the joint distribution of mass and radius : f(m,r|w,d,d&#39;)
    Refer to Ning et al. 2018 Sec 2.1, Eq 7
    &#39;&#39;&#39;

    deg = int(np.sqrt(len(weights)))
    deg_vec = np.arange(1,deg+1)

    joint = np.zeros((len(R_points), len(M_points)))

    for i in range(len(R_points)):
        for j in range(len(M_points)):
                    r_beta_indv = _find_indv_pdf(x=R_points[i], deg=deg, deg_vec=deg_vec, x_max=Radius_max, x_min=Radius_min, x_std=None, abs_tol=abs_tol, Log=False)
                    m_beta_indv = _find_indv_pdf(x=M_points[j], deg=deg, deg_vec=deg_vec, x_max=Mass_max, x_min=Mass_min, x_std=None, abs_tol=abs_tol, Log=False)

                    intermediate = np.matmul(np.reshape(weights,(deg,deg)),np.matrix(r_beta_indv).T)
                    joint[i,j] = np.matmul(np.matrix(m_beta_indv), intermediate)

    return joint.T</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="mrexo.mle_utils.MLE_fit"><code class="name flex">
<span>def <span class="ident">MLE_fit</span></span>(<span>Mass, Mass_sigma, Radius, Radius_sigma, Mass_bounds, Radius_bounds, deg, Log=True, abs_tol=1e-08, output_weights_only=False, save_path=None, calc_joint_dist=False, verbose=2)</span>
</code></dt>
<dd>
<section class="desc"><p>Perform maximum likelihood estimation to find the weights for the beta density basis functions.
Also, use those weights to calculate the conditional density distributions.
Ning et al. 2018 Sec 2.2, Eq 9.</p>
<pre><code>INPUT:
    Mass: Numpy array of mass measurements. In LINEAR SCALE.
    Mass_sigma: Numpy array of mass uncertainties.
        Assumes symmetrical uncertainty. In LINEAR SCALE.
    Radius: Numpy array of radius measurements. In LINEAR SCALE.
    Radius_sigma: Numpy array of radius uncertainties.
        Assumes symmetrical uncertainty. In LINEAR SCALE.
    Mass_bounds: Bounds for the mass. Log10
    Radius_bounds: Bounds for the radius. Log10
    deg: Degree used for beta densities polynomials. Integer value.
    Log: If True, data is transformed into Log scale. Default=True, 
        since the fitting function always converts data to log scale.
    abs_tol: Absolute tolerance to be used for the numerical integration
        for product of normal and beta distribution. Default : 1e-8
    output_weights_only: If True, only output the estimated weights, 
        else will also output dictionary with keys shown below.
    save_path: Location of folder for auxiliary output files.
    calc_joint_dist: If True, will calculate and output the
        joint distribution of mass and radius.
    verbose: Integer specifying verbosity for logging.
            If 0: Will not log in the log file or print statements.
            If 1: Will write log file only.
            If 2: Will write log file and print statements.
</code></pre>
<h2 id="output">OUTPUT</h2>
<pre><code>If output_weights_only == True,
w_hat : Weights for the beta densities.

If output_weights_only == False,
output: Output dictionary from fitting using 
        Maximum Likelihood Estimation.
        The keys in the dictionary are:
        'weights' : Weights for beta densities.
        'aic' : Akaike Information Criterion.
        'bic' : Bayesian Information Criterion.
        'M_points' : Sequence of mass points for 
            initial fitting w/o bootstrap.
        'R_points' : Sequence of radius points for
            initial fitting w/o bootstrap.
        'M_cond_R' : Conditional distribution of mass given radius.
        'M_cond_R_var' : Variance for the Conditional distribution 
            of mass given radius.
        'M_cond_R_quantile' : Quantiles for the Conditional distribution 
            of mass given radius.
        'R_cond_M' : Conditional distribution of radius given mass.
        'R_cond_M_var' : Variance for the Conditional distribution
            of radius given mass.
        'R_cond_M_quantile' : Quantiles for the Conditional distribution 
            of radius given mass.


        if calc_joint_dist == True:
        'joint_dist' : Joint distribution of mass AND radius.
</code></pre>
<p>EXAMPLE:</p>
<pre><code>    result = MLE_fit(Mass=Mass, Radius=Radius, Mass_sigma=Mass_sigma, 
                    Radius_sigma=Radius_sigma,
                    Mass_bounds=Mass_bounds, Radius_bounds=Radius_bounds, 
                    deg=int(deg_choose), abs_tol=abs_tol,
                    save_path=aux_output_location)
</code></pre></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def MLE_fit(Mass, Mass_sigma, Radius, Radius_sigma, Mass_bounds, Radius_bounds,
            deg, Log=True, abs_tol=1e-8, output_weights_only=False,
            save_path=None, calc_joint_dist = False, verbose=2):
    &#39;&#39;&#39;
    Perform maximum likelihood estimation to find the weights for the beta density basis functions.
    Also, use those weights to calculate the conditional density distributions.
    Ning et al. 2018 Sec 2.2, Eq 9.

    INPUT:
        Mass: Numpy array of mass measurements. In LINEAR SCALE.
        Mass_sigma: Numpy array of mass uncertainties.
            Assumes symmetrical uncertainty. In LINEAR SCALE.
        Radius: Numpy array of radius measurements. In LINEAR SCALE.
        Radius_sigma: Numpy array of radius uncertainties.
            Assumes symmetrical uncertainty. In LINEAR SCALE.
        Mass_bounds: Bounds for the mass. Log10
        Radius_bounds: Bounds for the radius. Log10
        deg: Degree used for beta densities polynomials. Integer value.
        Log: If True, data is transformed into Log scale. Default=True, 
            since the fitting function always converts data to log scale.
        abs_tol: Absolute tolerance to be used for the numerical integration
            for product of normal and beta distribution. Default : 1e-8
        output_weights_only: If True, only output the estimated weights, 
            else will also output dictionary with keys shown below.
        save_path: Location of folder for auxiliary output files.
        calc_joint_dist: If True, will calculate and output the
            joint distribution of mass and radius.
        verbose: Integer specifying verbosity for logging.
                If 0: Will not log in the log file or print statements.
                If 1: Will write log file only.
                If 2: Will write log file and print statements.

    \nOUTPUT:

        If output_weights_only == True,
        w_hat : Weights for the beta densities.

        If output_weights_only == False,
        output: Output dictionary from fitting using 
                Maximum Likelihood Estimation.
                The keys in the dictionary are:
                &#39;weights&#39; : Weights for beta densities.
                &#39;aic&#39; : Akaike Information Criterion.
                &#39;bic&#39; : Bayesian Information Criterion.
                &#39;M_points&#39; : Sequence of mass points for 
                    initial fitting w/o bootstrap.
                &#39;R_points&#39; : Sequence of radius points for
                    initial fitting w/o bootstrap.
                &#39;M_cond_R&#39; : Conditional distribution of mass given radius.
                &#39;M_cond_R_var&#39; : Variance for the Conditional distribution 
                    of mass given radius.
                &#39;M_cond_R_quantile&#39; : Quantiles for the Conditional distribution 
                    of mass given radius.
                &#39;R_cond_M&#39; : Conditional distribution of radius given mass.
                &#39;R_cond_M_var&#39; : Variance for the Conditional distribution
                    of radius given mass.
                &#39;R_cond_M_quantile&#39; : Quantiles for the Conditional distribution 
                    of radius given mass.


                if calc_joint_dist == True:
                &#39;joint_dist&#39; : Joint distribution of mass AND radius.
    EXAMPLE:

            result = MLE_fit(Mass=Mass, Radius=Radius, Mass_sigma=Mass_sigma, 
                            Radius_sigma=Radius_sigma,
                            Mass_bounds=Mass_bounds, Radius_bounds=Radius_bounds, 
                            deg=int(deg_choose), abs_tol=abs_tol,
                            save_path=aux_output_location)
    &#39;&#39;&#39;
    print(&#39;New MLE&#39;)
    starttime = datetime.datetime.now()
    if save_path is None:
        save_path = os.path.dirname(__file__)


    message = &#39;\n====\nStarted run at {}\n&#39;.format(starttime)
    _ = _logging(message=message, filepath=save_path, verbose=verbose, append=True)


    n = np.shape(Mass)[0]
    Mass_max = Mass_bounds[1]
    Mass_min = Mass_bounds[0]
    Radius_max = Radius_bounds[1]
    Radius_min = Radius_bounds[0]

    ########################################################################
    # Integration to find C matrix (input for log likelihood maximization.)
    ########################################################################
    C_pdf = calc_C_matrix(n=n, deg=deg, M=Mass, Mass_sigma=Mass_sigma, Mass_max=Mass_max, Mass_min=Mass_min,
                        R=Radius, Radius_sigma=Radius_sigma, Radius_max=Radius_max, Radius_min=Radius_min,
                        Log=Log, abs_tol=abs_tol, save_path=save_path, verbose=verbose)

    message = &#39;Finished Integration at {}. Calculated the PDF for Mass and Radius for Integrated beta and normal density &#39;.format(datetime.datetime.now())
    _ = _logging(message=message, filepath=save_path, verbose=verbose, append=True)


    ###########################################################
    # Run optimization to find the weights
    ###########################################################

    # Ensure that the weights always sum up to 1.
    def eqn(w):
        return np.sum(w) - 1

    # Function input to optimizer
    def fn1(w):
        a = - np.sum(np.log(np.matmul(w,C_pdf)))
        return a

    # Define a list of lists of bounds
    bounds = [[0,1]]*(deg-2)**2
    # Initial value for weights
    x0 = np.repeat(1./(deg**2),(deg-2)**2)

    # Run optimization to find optimum value for each degree (weights). These are the coefficients for the beta densities being used as a linear basis.
    opt_result = fmin_slsqp(fn1, x0, bounds=bounds, f_eqcons=eqn, iter=250, full_output=True, iprint=1,
                            epsilon=1e-5, acc=1e-5)
    message = &#39;Optimization run finished at {}, with {} iterations. Exit Code = {}&#39;.format(datetime.datetime.now(),
            opt_result[2], opt_result[3], opt_result[4])
    _ = _logging(message=message, filepath=save_path, verbose=verbose, append=True)


    unpadded_weight = opt_result[0]
    n_log_lik = opt_result[1]

    # Pad the weight array with zeros for the
    w_sq = np.reshape(unpadded_weight,[deg-2,deg-2])
    w_sq_padded = np.zeros((deg,deg))
    w_sq_padded[1:-1,1:-1] = w_sq
    w_hat = w_sq_padded.flatten()

    if output_weights_only == True:
        return unpadded_weight

    else:
        # Calculate AIC and BIC
        aic = n_log_lik*2 + 2*(deg**2 - 1)
        bic = n_log_lik*2 + np.log(n)*(deg**2 - 1)

        M_seq = np.linspace(Mass_min,Mass_max,100)
        R_seq = np.linspace(Radius_min,Radius_max,100)

        output = {&#39;weights&#39;: w_hat,
                  &#39;aic&#39;: aic,
                  &#39;bic&#39;: bic,
                  &#39;M_points&#39;: M_seq,
                  &#39;R_points&#39;: R_seq}


        deg_vec = np.arange(1,deg+1)

        M_cond_R_median, M_cond_R_var, M_cond_R_quantile = [], [], []
        R_cond_M_median, R_cond_M_var, R_cond_M_quantile = [], [], []

        for i in range(0,len(R_seq)):
            # Conditional Densities with 16% and 84% quantile
            M_cond_R = cond_density_quantile(y = R_seq[i], y_max = Radius_max, y_min = Radius_min,
                            x_max = Mass_max, x_min = Mass_min, deg = deg, deg_vec = deg_vec, w_hat = w_hat, qtl = [0.5,0.16,0.84])[0:3]
            M_cond_R_median.append(M_cond_R[2][0])
            M_cond_R_var.append(M_cond_R[1])
            M_cond_R_quantile.append(M_cond_R[2][1:])

            R_cond_M = cond_density_quantile(y = M_seq[i], y_max=Mass_max, y_min=Mass_min,
                                x_max=Radius_max, x_min=Radius_min, deg=deg, deg_vec = deg_vec,
                                w_hat=np.reshape(w_hat,(deg,deg)).T.flatten(), qtl = [0.5,0.16,0.84])[0:3]
            R_cond_M_median.append(R_cond_M[2][0])
            R_cond_M_var.append(R_cond_M[1])
            R_cond_M_quantile.append(R_cond_M[2][1:])



        # Output everything as dictionary

        output[&#39;M_cond_R&#39;] = M_cond_R_median
        output[&#39;M_cond_R_var&#39;] = M_cond_R_var
        output[&#39;M_cond_R_quantile&#39;] = np.array(M_cond_R_quantile)
        output[&#39;R_cond_M&#39;] = R_cond_M_median
        output[&#39;R_cond_M_var&#39;] = R_cond_M_var
        output[&#39;R_cond_M_quantile&#39;] = np.array(R_cond_M_quantile)

        if calc_joint_dist == True:
            joint_dist = calculate_joint_distribution(R_seq, Radius_min, Radius_max, M_seq, Mass_min, Mass_max, w_hat, abs_tol)
            output[&#39;joint_dist&#39;] = joint_dist

        return output</code></pre>
</details>
</dd>
<dt id="mrexo.mle_utils.calc_C_matrix"><code class="name flex">
<span>def <span class="ident">calc_C_matrix</span></span>(<span>n, deg, M, Mass_sigma, Mass_max, Mass_min, R, Radius_sigma, Radius_max, Radius_min, abs_tol, save_path, Log, verbose)</span>
</code></dt>
<dd>
<section class="desc"><p>Integrate the product of the normal and beta distributions for mass and radius and then take the Kronecker product.</p>
<pre><code>Refer to Ning et al. 2018 Sec 2.2 Eq 8 and 9.
</code></pre>
<h2 id="inputs">INPUTS</h2>
<pre><code>n: Number of data points
deg: Degree used for beta densities
Mass: Numpy array of mass measurements. In LINEAR SCALE.
Mass_sigma: Numpy array of mass uncertainties. Assumes symmetrical uncertainty. In LINEAR SCALE.
Mass_max, Mass_min : Maximum and minimum value for mass. Log10
Radius: Numpy array of radius measurements. In LINEAR SCALE.
Radius_sigma: Numpy array of radius uncertainties. Assumes symmetrical uncertainty. In LINEAR SCALE.
Radius_max, Radius_min : Maximum and minimum value for radius. Log10
abs_tol: Absolute tolerance to be used for the numerical integration for product of normal and beta distribution.
        Default : 1e-8
save_path: Location of folder within results for auxiliary output files
Log: If True, data is transformed into Log scale. Default=True, since
    fitting function always converts data to log scale.
verbose: Integer specifying verbosity for logging.
    If 0: Will not log in the log file or print statements.
    If 1: Will write log file only.
    If 2: Will write log file and print statements.
</code></pre>
<p>OUTPUTS:</p>
<pre><code>C_pdf : Matrix explained in Ning et al. Equation 8. Product of (integrals of (product of normal and beta
        distributions)) for mass and radius.
</code></pre></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def calc_C_matrix(n, deg, M, Mass_sigma, Mass_max, Mass_min, R, Radius_sigma, Radius_max, Radius_min, abs_tol, save_path, Log, verbose):
    &#39;&#39;&#39;
    Integrate the product of the normal and beta distributions for mass and radius and then take the Kronecker product.

    Refer to Ning et al. 2018 Sec 2.2 Eq 8 and 9.

    \nINPUTS:
        n: Number of data points
        deg: Degree used for beta densities
        Mass: Numpy array of mass measurements. In LINEAR SCALE.
        Mass_sigma: Numpy array of mass uncertainties. Assumes symmetrical uncertainty. In LINEAR SCALE.
        Mass_max, Mass_min : Maximum and minimum value for mass. Log10
        Radius: Numpy array of radius measurements. In LINEAR SCALE.
        Radius_sigma: Numpy array of radius uncertainties. Assumes symmetrical uncertainty. In LINEAR SCALE.
        Radius_max, Radius_min : Maximum and minimum value for radius. Log10
        abs_tol: Absolute tolerance to be used for the numerical integration for product of normal and beta distribution.
                Default : 1e-8
        save_path: Location of folder within results for auxiliary output files
        Log: If True, data is transformed into Log scale. Default=True, since
            fitting function always converts data to log scale.
        verbose: Integer specifying verbosity for logging.
            If 0: Will not log in the log file or print statements.
            If 1: Will write log file only.
            If 2: Will write log file and print statements.

    OUTPUTS:

        C_pdf : Matrix explained in Ning et al. Equation 8. Product of (integrals of (product of normal and beta
                distributions)) for mass and radius.
    &#39;&#39;&#39;
    deg_vec = np.arange(2,deg)

    M_indv_pdf = np.zeros((n, deg-2))
    R_indv_pdf = np.zeros((n, deg-2))
    C_pdf = np.zeros((n, (deg-2)**2))


    message = &#39;Started Integration at {}\n&#39;.format(datetime.datetime.now())
    _ = _logging(message=message, filepath=save_path, verbose=verbose, append=True)



    # Loop across each data point.
    for i in range(0,n):
        M_indv_pdf[i,:] = _find_indv_pdf(M[i], deg, deg_vec, Mass_max, Mass_min, Mass_sigma[i], abs_tol=abs_tol, Log=Log)
        R_indv_pdf[i,:] = _find_indv_pdf(R[i], deg, deg_vec, Radius_max, Radius_min, Radius_sigma[i], abs_tol=abs_tol, Log=Log)
        # print(M[i],Mass_sigma[i], R[i], Radius_sigma[i], Mass_max, Mass_min, Radius_max, Radius_min, np.sum(R_indv_pdf[i,:]))

        # Put M.indv.pdf and R.indv.pdf into a big matrix
        C_pdf[i,:] = np.kron(M_indv_pdf[i], R_indv_pdf[i])

    C_pdf = C_pdf.T

    # Log of 0 throws weird errors
    C_pdf[C_pdf == 0] = 1e-300
    C_pdf[np.where(np.isnan(C_pdf))] = 1e-300
    return C_pdf</code></pre>
</details>
</dd>
<dt id="mrexo.mle_utils.calculate_joint_distribution"><code class="name flex">
<span>def <span class="ident">calculate_joint_distribution</span></span>(<span>R_points, Radius_min, Radius_max, M_points, Mass_min, Mass_max, weights, abs_tol)</span>
</code></dt>
<dd>
<section class="desc"><p>Calculcate the joint distribution of mass and radius : f(m,r|w,d,d')
Refer to Ning et al. 2018 Sec 2.1, Eq 7</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def calculate_joint_distribution(R_points, Radius_min, Radius_max, M_points, Mass_min, Mass_max, weights, abs_tol):
    &#39;&#39;&#39;
    Calculcate the joint distribution of mass and radius : f(m,r|w,d,d&#39;)
    Refer to Ning et al. 2018 Sec 2.1, Eq 7
    &#39;&#39;&#39;

    deg = int(np.sqrt(len(weights)))
    deg_vec = np.arange(1,deg+1)

    joint = np.zeros((len(R_points), len(M_points)))

    for i in range(len(R_points)):
        for j in range(len(M_points)):
                    r_beta_indv = _find_indv_pdf(x=R_points[i], deg=deg, deg_vec=deg_vec, x_max=Radius_max, x_min=Radius_min, x_std=None, abs_tol=abs_tol, Log=False)
                    m_beta_indv = _find_indv_pdf(x=M_points[j], deg=deg, deg_vec=deg_vec, x_max=Mass_max, x_min=Mass_min, x_std=None, abs_tol=abs_tol, Log=False)

                    intermediate = np.matmul(np.reshape(weights,(deg,deg)),np.matrix(r_beta_indv).T)
                    joint[i,j] = np.matmul(np.matrix(m_beta_indv), intermediate)

    return joint.T</code></pre>
</details>
</dd>
<dt id="mrexo.mle_utils.cond_density_quantile"><code class="name flex">
<span>def <span class="ident">cond_density_quantile</span></span>(<span>y, y_max, y_min, x_max, x_min, deg, deg_vec, w_hat, y_std=None, qtl=[0.16, 0.84], abs_tol=1e-08)</span>
</code></dt>
<dd>
<section class="desc"><p>Calculate 16% and 84% quantiles of a conditional density, along with the mean and variance.</p>
<p>Refer to Ning et al. 2018 Sec 2.2, Eq 10</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def cond_density_quantile(y, y_max, y_min, x_max, x_min, deg, deg_vec, w_hat, y_std=None, qtl=[0.16,0.84], abs_tol=1e-8):
    &#39;&#39;&#39;
    Calculate 16% and 84% quantiles of a conditional density, along with the mean and variance.

    Refer to Ning et al. 2018 Sec 2.2, Eq 10
    &#39;&#39;&#39;
    if type(y) == list:
        y = np.array(y)

    y_beta_indv = _find_indv_pdf(x=y, deg=deg, deg_vec=deg_vec, x_max=y_max, x_min=y_min, x_std=y_std, abs_tol=abs_tol, Log=False)
    y__beta_pdf = np.kron(np.repeat(1,np.max(deg_vec)),y_beta_indv)

    # Equation 10b Ning et al 2018
    denominator = np.sum(w_hat * y__beta_pdf)

    if denominator == 0:
        denominator = np.nan

    # Mean
    mean_beta_indv = (deg_vec * (x_max - x_min) / (deg + 1)) + x_min
    mean_beta = np.kron(mean_beta_indv,y_beta_indv)
    mean_numerator = np.sum(w_hat * mean_beta)
    mean = mean_numerator / denominator

    # Variance
    var_beta_indv = (deg_vec * (deg - deg_vec + 1) * (x_max - x_min)**2 / ((deg + 2)*(deg + 1)**2))
    var_beta = np.kron(var_beta_indv,y_beta_indv)
    var_numerator = np.sum(w_hat * var_beta)
    var = var_numerator / denominator

    # Quantile

    def pbeta_conditional_density(j):
        if type(j) == np.ndarray:
            j = j[0]
        x_indv_cdf = np.array([beta.cdf((j - x_min)/(x_max - x_min), a=d, b=deg - d + 1) for d in deg_vec])
        quantile_numerator = np.sum(w_hat * np.kron(x_indv_cdf,y_beta_indv))
        p_beta = quantile_numerator / denominator

        return p_beta


    def conditional_quantile(q):
        def g(x):
            return pbeta_conditional_density(x) - q
        return root(g,a=x_min, b=x_max, xtol=1e-8, rtol=1e-12)


    if np.size(qtl) == 1:
        qtl = [qtl]
    quantile = [conditional_quantile(i) for i in qtl]

    return mean, var, quantile, denominator, y_beta_indv</code></pre>
</details>
</dd>
<dt id="mrexo.mle_utils.integrate_function"><code class="name flex">
<span>def <span class="ident">integrate_function</span></span>(<span>data, data_std, deg, degree, x_max, x_min, Log=False, abs_tol=1e-08)</span>
</code></dt>
<dd>
<section class="desc"><p>Integrate the product of the normal and beta distribution.</p>
<p>Refer to Ning et al. 2018 Sec 2.2, Eq 8.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def integrate_function(data, data_std, deg, degree, x_max, x_min, Log=False, abs_tol=1e-8):
    &#39;&#39;&#39;
    Integrate the product of the normal and beta distribution.

    Refer to Ning et al. 2018 Sec 2.2, Eq 8.
    &#39;&#39;&#39;
    x_obs = data
    x_std = data_std
    shape1 = degree
    shape2 = deg - degree + 1
    Log = Log

    integration_product = quad(_pdfnorm_beta, a=x_min, b=x_max,
                          args=(x_obs, x_std, x_max, x_min, shape1, shape2, Log), epsabs = abs_tol, epsrel = 1e-8)
    return integration_product[0]</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="mrexo" href="index.html">mrexo</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="mrexo.mle_utils.MLE_fit" href="#mrexo.mle_utils.MLE_fit">MLE_fit</a></code></li>
<li><code><a title="mrexo.mle_utils.calc_C_matrix" href="#mrexo.mle_utils.calc_C_matrix">calc_C_matrix</a></code></li>
<li><code><a title="mrexo.mle_utils.calculate_joint_distribution" href="#mrexo.mle_utils.calculate_joint_distribution">calculate_joint_distribution</a></code></li>
<li><code><a title="mrexo.mle_utils.cond_density_quantile" href="#mrexo.mle_utils.cond_density_quantile">cond_density_quantile</a></code></li>
<li><code><a title="mrexo.mle_utils.integrate_function" href="#mrexo.mle_utils.integrate_function">integrate_function</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.6.2</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>